# -*- coding: utf-8 -*-
"""Day4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YZ8TwI1mDQbq2GrIkniOlpakYomdbTv0
"""

#Object oriented.
class Student:
  roll_number=101
  num1=50
  num2=100

  def add(self):
    print(self.num1+self.num2)
    self.name=input("Enter your name:")
    print(self.name)

obj=Student()
obj.add()
print(obj.roll_number)
print(obj.name)

#Constructor
#It will initialize the object means it first check that how much memory is require for class the it gives the reference of that memeory to the class object
class NewClass:
  def __init__(self):
    print("My name is constructor and i always execute first")
  def show(self):
    print("Welcome to class level programming")

obj=NewClass()
print(obj)
obj.show()
obj1=NewClass()

class  Hod:
  def __init__(self): #default constructor
    self.name="Aditya Shinde"
    self.age=22
    self.empid=1001

  def info(self):
    print("My name is:",self.name)
    print("My age is:",self.age)
    print("My employee id is:",self.empid)
obj=Hod()
obj.info()

class Hod:
  def __init__(self,name,age,rollno):#parametarized constructor
    self.name=name
    self.age=age
    self.rollno=rollno


  def show(self):
    print("My name is:",self.name)
    print("My age is:",self.age)
    print("My rollno is:",self.rollno)

obj=Hod('Aditya',22,56)
obj.show()

class New:
  def __init__(self):
    self.a=10  #Instance variable.It creates separate memory

obj1=New()
obj2=New()
obj3=New()
obj1.a=20
print(obj1.a)
print(obj2.a)
print(obj3.a)

#__dict__():-It show the class data in dictionary format
class Student:
  def __init__(self):
    self.f_name="Aditya"
    self.l_name="Shinde"
    self.rollno=56
    self.branch="CS"
    self.mb=354165465165

obj=Student()
print(obj.__dict__)

#untill we do not call method it will not get addresss in memory
class Student:
  def __init__(self):
    self.f_name="Aditya"
    self.l_name="Shinde"
    self.rollno=56
    self.branch="CS"
  def getdata(self):
    self.mb=1236547899

obj=Student()
obj.getdata()
print(obj.__dict__)
print(obj.mb)

class Student:
  def __init__(self):
    self.s_name="Aditya"
    self.s_rollno=101

  def getdata(self):
    self.s_mb=1236547899

obj=Student()
obj.getdata()
obj.s_branch="CS"
print(obj.__dict__)
# print(obj.mb)

class College:
  collegeName="GIT" #static var
  def __init__(self):
    self.studentName="Aditya" #instance var

principal=College()
teacher=College()
accoundant=College()

print("principal=",principal.collegeName,"......",principal.studentName)
print("teacher=",teacher.collegeName,"......",teacher.studentName)
print("accoundant=",accoundant.collegeName,"......",accoundant.studentName)

College.collegeName="HBD" #second way to add stativc var
principal.studentName="Prashant Jha" #it will change only for principal object

print("principal=",principal.collegeName,"......",principal.studentName)
print("teacher=",teacher.collegeName,"......",teacher.studentName)
print("accoundant=",accoundant.collegeName,"......",accoundant.studentName)

class Student:
  def __init__(self):
    Student.name="Aditya"

  def info(self):
    Student.age=34


obj=Student()
print(obj.name)
obj.info()
print(Student.age)

import sys

class CRUD:
  def __init__(self):
    print("Student Management System")
    self.studentID=[]
    self.studentName=[]
    self.studentRollNo=[]
    self.studentCity=[]

  def addStudent(self):
    self.studentID.append(input("Enter student ID:"))
    self.studentRollNo.append(input("Enter student rollno:"))
    self.studentName.append(input("Enter student name:"))
    self.studentCity.append(input("Enter student city:"))



  def showinfo(self):
    print("studentID\t\tstudentRollNo\t\tstudent name\t\tstudentcity\t\t")

    for x in range(60):
      print("-",end=" ")

    print()
    for i in range(len(self.studentID)):
      print(self.studentID[i],"\t\t",self.studentRollNo[i],"\t\t",self.studentName[i],"\t\t",self.studentCity[i],"\t\t")

  def updateStudent(self):
    newInputID=input("Enter student ID:")
    for i in range(len(self.studentID)):
      print("Matched student data is:")
      print("1.Student Roll no:",self.studentRollNo[i],'\n',print("2.Student name:"),self.studentName[i],'\n')



  def deleteStudent(self):
    newStudentID=input("Enter student ID:")
    k=0
    for i in self.studentID:
      if newStudentID==1:
        print("Matched student data are:")
        print("1.Student Roll no:",self.studentRollNo[i],'\n',"2.Student name:",self.studentName[i],'\n',"3.Student City:",self.studentCity[i],'\n')

        c=input("do you ant to delete this recore(y/n):")
        if c=="y" or c=="Y":
          del self.studentID[k]
          del self.studentRollNo[k]
          del self.studentName[k]
          del self.studentCity[k]




  def start(self):
    obj=CRUD()

    while True:
      print("1.Add Student")
      print("2.Show Student info")
      print("3.Update Student info")
      print("4.Delete Student info")
      print("5.Exit")

      c=int(input("Enter your choice:"))

      if c==1:
          obj.addStudent()
      elif c==2:
          obj.showinfo()
      elif c==3:
          obj.updateStudent()
      elif c==4:
        obj.deleteStudent()

      elif c==5:
        sys.exit()
      else:
        print("Please select correct choice...\n")







if __name__=="main":
  obj.CRUD()
  obj.start()

#42
#single level inheritence

class College: #parent class
  def college_name(self):
    print("Modern College")

class Student(College):#child class
  def std_info(self):
    print("Name:Aditya")
    print("Branch:Computer")


obj=Student()
obj.college_name()
obj.std_info()

#Multilevel inheritence
class College:
  def college_name(self):
    print("GIT")

class Student(College):
  def student_info(self):
    print("Name:Aditya")
    print("Branch:Computer")


class Exam(Student):
  def subject(self):
    print("Subject1:DS")
    print("Subject2:ML")
    print("Subject3:ADS")

obj=Exam()
obj.college_name()
obj.student_info()

#Multiple inheritence

class SubMarks:
  math=int(input("Enter paper marks of math :"))
  DE=int(input("Enter paper marks of DE:"))
  c=int(input("Enter paper marks of c:"))
  english=int(input("Enter paper marks of english:"))

class PracMarks:
  cpract=int(input("Enter practical marks of c:"))

class Result(SubMarks,PracMarks):
  def total(self):
    if self.math>=40 and self.DE>=40 and self.english>=40:
      print("pass")
    else:
      print("Fail")

obj=Result()
obj.total()

class A:
  def add(self):
    print(2+2)

class B:
  def add(self):
    print(3+3)

class C(A,B):
  def display(self):
    print("msg display")

obj=C()
obj.add()

#method
class Arithematic:
  def add(self,a):
    print(a)

  def add(self,a,b):
    print(a+b)

  def add(self,a,b,c):
    print(a+b+c)

obj=Arithematic()
obj.add(10)
obj.add(10,20)
obj.add(10,20,30)

#solution for method overloading
class Arithematic:
  def add(self,a=None,b=None,c=None):
    if a!=None and b!=None:
      print(a+b)
    elif a!=None and b!=None and c!=None:
      print(a+b+c)
    else:
      print("Enter atleast two arguments")

obj = Arithematic()
obj.add(10)
obj.add(10,20)
obj.add(10,30)

#Constructor overloading not supported in python
#when object is called then always last constructor will executed
class Arithematic:
  def __init__(self):
    print("There is no argumnent")
  def __init__(self,a):
    print("There are one argumnent")
  def __init__(self,a,b):
    print("There is two argumnent")

obj=Arithematic()
obj=Arithematic(10)
obj=Arithematic(3,2)

#Operator overloading:-supoorted in python

class Deposit:
  def __init__(self,cash):
    self.cash=cash

d1=Deposit(1000)
d2=Deposit(1000)
print(d1+d2)

# This is a special method called __add__, which overrides the behavior of the + operator for objects of the Deposit class.

# When you use the + operator between two Deposit objects (like d1 + d2), Python will internally call this __add__ method.

# The method receives two parameters: self (the left-hand operand, i.e., d1) and other (the right-hand operand, i.e., d2).

# Inside the __add__ method, it returns the sum of self.cash and other.cash, i.e., the cash attribute of the two Deposit objects.

class Deposit:
  def __init__(self,cash):
    self.cash=cash
  def __add__(self,other):
    return self.cash+other.cash

d1=Deposit(1000)
d2=Deposit(1000)
print(d1+d2)

#Method overriding
#by using super() method we can use parent class method in child class

class Rbi:
  def homeloan_ROI(self):
    print("Home loan ROI=7.5%")
  def carloan_ROI(self):
    print("car loan ROI=8%")

class Sbi(Rbi):
  def homeloan_ROI(self):
    print("Home loan ROI=6.5%")

obj=Sbi()
obj.homeloan_ROI()
obj.carloan_ROI()

#by using super() method we can use parent class method in child class

class Rbi:
  def homeloan_ROI(self):
    print("Home loan ROI=7.5%")
  def carloan_ROI(self):
    print("car loan ROI=8%")

class Sbi(Rbi):
  def homeloan_ROI(self):
    print("Home loan ROI=6.5%")
    super().homeloan_ROI()

obj=Sbi()
obj.homeloan_ROI()
obj.carloan_ROI()

#Constructor overriding
class Father:
  def __init__(self):
    print("Father:-I am already at breakfast table")

class Child(Father):
  def __init__(self):
    super().__init__()
    print("Child:-I will be late for breakfast")



obj=Child()

mylist=[5,1,1,2,3,5,6,7]
newlist=[]

for i in range(len(mylist)):
  count=0
  key=mylist[i]

  j=i-1
  while j<len(mylist):
    if key==mylist[j]:
      newlist.append(key)
    j=j+1
print(len(newlist))

a={(1,2):1,(2,3):2,(4,5):3}
print(a[4,5])#4,5 are keys so it will return the value related to it

#can not access two keys at same time
a={'a':1,'b':2,'c':3}
print(a['a','b'])

fruit={}
def addone(index):
  if index in fruit:
    fruit[index]+=1
  else:
    fruit[index]=1

addone('Apple')
addone('Banana')
addone('apple')
print(len(fruit))

arr={}
arr[1]=1
arr['1']=2
arr[1]+=1

sum=0
for i in arr:
  sum+=arr[i]
print(sum)
print(arr)

my_dict={}
my_dict[1]=1
my_dict['1']=2
my_dict[1.0]=4

sum=0
for k in my_dict:
  sum+=my_dict[k]

print(sum)
print(my_dict)

my_dict={}
my_dict[(1,2,4)]=8
my_dict[(4,2,1)]=10
my_dict[(1,2)]=12

sum=0

for k in my_dict:
  sum+=my_dict[k]

print(sum)
print(my_dict)

box={}
jars={}
creates={}
box['biscuit']=1
box['cake']=3

jars['jam']=4

creates['box']=box
creates['jars']=jars

print(len(creates[box]))

dict={'c':97,'a':98,'b':99}

for _ in sorted(dict):
  print(dict[_])

rec={'Name':"pthon","Age":20}
r=rec.copy()
print(id(r)==id(rec))
print(id(rec))
print(id(r))

rec={"Name":"Aditya","Age":20,"Addr":"NJ","Country":"IN"}
id1=id(rec)
del rec

rec={"Name":"Aditya","Age":20,"Addr":"NJ","Country":"IN"}
id2=id(rec)
print(id1==id2)

#static method
class Student:
  @staticmethod
  def get_personal_detail(firstname,lastname):
    print("your personal detail=",firstname,lastname)

  @staticmethod
  def contact_detail(mobile_no,rollno):
    print("your contact deatil=",mobileno,rollno)

  Student.get_personal_detail("Aditya","Shinde")
  Student.contact_detail(222233,56)